NAME

    Devel::Examine::Subs - Get info, search/replace and inject code in Perl
    file subs.

SYNOPSIS

        use Devel::Examine::Subs;
    
        my $file = 'perl.pl'; # or directory name
        my $search = 'string';
    
        my $des = Devel::Examine::Subs->new({file => $file);

    Get all sub names in a file

        my $aref = $des->all();

    Print all subs within each Perl file under a directory

        my $href = $des->all({ file => 'lib/Devel/Examine' });
    
        for my $file (keys %$href){
            print "\n$file\n";
            print "\t$_\n" for @{$href->{$file}};
        }

    Get all subs containing "string" in the body

        my $aref = $des->has({search => $search});

    Search and replace code in subs

        $des->search_replace({
                        search => "$template = 'one.tmpl'",
                        replace => "$template = 'two.tmpl'",
                      });

    Inject code into sub after a search term (preserves previous line's
    indenting)

        my @code = <DATA>;
    
        $des->inject_after({
                        search => 'this', 
                        code => \@code, 
                      });
    
        __DATA__
    
        # previously uncaught issue
    
        if ($foo eq "bar"){
            croak 'big bad error';
        }

    Get all the subs as objects

        $aref = $des->objects(...)
    
        for my $sub (@$aref){
            print $sub->name() # name of sub
            print $sub->start() # first line of sub
            print $sub->stop() # last line of sub
            print $sub->num_lines() # number of lines in sub
        }

    Print out all lines in all subs that contain a search term

        my $ret = $des->lines({search => 'this'});
    
        for my $sub (%$ret){
            for my $lines (@{$ret->{$sub}}){
                print "\nSubroutine $sub:\n";
                while (my ($line_no, $code) = each (%$lines)){
                    print "Line num: $line_no, Code: $code\n";
                }
            }
        }

    Same, but after searching a directory, not a single file

        my $ret = $des->lines({file => 'lib/Devel/Examine', search => 'core'});
    
        for my $file (keys %$ret){
            print "\n$file\n";
            for my $sub (keys %{$ret->{$file}}){
                print "\nSub: $sub\n";
                for my $lines (@{$ret->{$file}{$sub}}){
                    while (my ($line_no, $code) = each (%$lines)){
                        print "\tLine num: $line_no:\t $code\n";
                    }
                }
            }
        }

DESCRIPTION

    Gather information about subroutines in Perl files (and in-memory
    modules), with the ability to search/replace code, inject new code, get
    line counts and a myriad of other options.

FEATURES

    - uses PPI for Perl file parsing

    - search and replace code within subs, with the ability to include or
    exclude subs, something a global search/replace can't do

    - inject new code into subs following a found search pattern

    - retrieve all sub names where the sub does or doesn't contain a search
    term

    - retrieve a list of sub objects for subs that match a search term,
    where each object contains a list of line numbers along with the full
    lines that match

    - include or exclude subs to be processed

    - differentiates a directory from a file, and acts accordingly by
    recursing and processing specified files

    - extremely modular and extensible; the core of the system uses
    plugin-type callbacks for everything

    - pre-defined callbacks are used by default, but user-supplied ones are
    loaded dynamically

METHODS

 new({ file = $filename })>

    Instantiates a new object.

    Optionally takes the name of a file to search. If $filename is a
    directory, it will be searched recursively for files. You can set any
    and all parameters this module uses in new(), however only 'file',
    'include' and 'exclude' will remain persistent across runs under the
    same DES object.

    Note that all public methods of this module can accept all documented
    parameters, but of course will only use the ones they're capable of
    using.

 has({ file = $filename, search => $text })>

    Returns an array reference containing the names of the subs where the
    subroutine contains the text.

 missing({ file = $filename, search => $text })>

    The exact opposite of has.

 all({ file = $filename })>

    Returns an array reference containing the names of all subroutines
    found in the file.

 module({ module = 'Devel::Examine::Subs' } )>

    Returns an array reference containing the names of all subs found in
    the module's namespace symbol table.

 lines({ file = $filename, search => $text })>

    Gathers together all line text and line number of all subs where the
    sub contains lines matching the search term.

    Returns a hash reference with the sub name as the key, the value being
    an array reference which contains a hash reference in the format
    line_number => line_text.

 search_replace({ file = $file, $search => 'this', $replace => 'that' })>

    Search for lines that contain certain text, and replace the search term
    with the replace term.

    This method will create a backup copy of the file with the same name
    appended with '.bak'.

 run()

    All public methods call this method internally. The public methods set
    certain variables (filters, engines etc). You can get the same effect
    programatically by using run(). Here's an example that performs the
    same operation as the has() public method:

        my $params = {
                search => 'text',
                pre_filter => 'file_lines_contain',
                engine => 'has',
        };
    
        my $return = $des->run($params);

    This allows for very fine-grained interaction with the application, and
    makes it easy to write new engines and for testing.

 inject_after({ file = $file, search => 'this', code => \@code })>

    WARNING!: This functionality is risky. For starters, there's no way
    currently to disable it from inserting after each found term, so if you
    don't want that, you have to use a search term that you're confident
    only appears once in each sub (my $self = shift; for example). This
    will be fixed in the next release.

    Injects the code in @code into the sub within the file, where the sub
    contains the search term. The same indentation level of the line that
    contains the search term is used for any new code injected. Set
    no_indent parameter to a true value to disable this feature.

    The code array should contain one line of code (or blank line) per each
    element. (See SYNOPSIS for an example).

    Optional parameters:

    copy

      See search_replace() for a description of how this parameter is used.

 pre_procs()

    Returns a list of all available pre processor modules.

 pre_filters()

    Returns a list of all available built-in pre engine filter modules.

 engines()

    Returns a list of all available built-in 'engine' modules.

 add_functionality()

    WARNING!: This method is highly experimental and is used for developing
    internal processors only. Only 'engine' is functional, and only half
    way. It's simply a proof-of-concept of the 'Processor' structure which
    I will be incorporating into a new module template system that allows
    people to replicate the base structure of this module (less the data
    and processors). DO NOT USE.

    While writing new processors, set the processor type to a callback
    within the local working file. When the code performs the actions you
    want it to, put a comment line before the code with #<des> and a line
    following the code with #</des>. DES will slurp in all of that code
    live-time, inject it into the specified processor, and configure it for
    use. See examples/write_new_engine.pl for an example of creating a new
    'engine' processor.

    Parameters:

    add_functionality

      Informs the system which type of processor to inject and configure.
      Permitted values are 'pre_proc', 'pre_filter' and 'engine'.

    add_functionality_prod

      Set to a true value, will update the code in the actual installed
      Perl module file, instead of a local copy.

    Optional parameters:

    copy Set it to a new file name which will copy the original, and only
    change the copy. Useful for verifying the changes took properly.

PARAMETERS

    There are various optional parameters that can be used.

    include

      An array reference containing the names of subs to include. This (and
      exclude) tell the Processor phase to generate only these subs,
      significantly reducing the work that needs to be done in subsequent
      method calls. Best to set it in the new() method.

    exclude

      An array reference of the names of subs to exclude. See include for
      further details.

    no_indent

      In the processes that write new code to files, the indentation level
      of the line the search term was found on is used for inserting the
      new code by default. Set this parameter to a true value to disable
      this feature and set the new code at the beginning column of the
      file.

    pre_proc_dump, pre_filter_dump, engine_dump, core_dump

      Set to 1 to activate.

      Print to STDOUT using Data::Dumper the structure of the data
      following the respective phase. The core_dump will print the state of
      the data, as well as the current state of the entire DES object.

      NOTE: The 'pre_filter' phase is run in such a way that pre-filters
      can be daisy-chained. Due to this reason, the value of
      pre_filter_dump works a little differently. For example:

          pre_filter => 'one && two';

      ...will execute filter 'one' first, then filter 'two' with the data
      that came out of filter 'one'. Simply set the value to the number
      that coincides with the location of the filter. For instance,
      pre_filter_dump = 2;> will dump the output from the second filter and
      likewise, 1 will dump after the first.

    pre_proc_return, pre_filter_return, engine_return

      Returns the structure of data immediately after being processed by
      the respective phase. Useful for writing new 'phases'. (See "SEE
      ALSO" for details).

      NOTE: pre_filter_return does not behave like pre_filter_dump. It will
      only return after all pre-filters have executed.

    clean_config

      Resets all configuration parameters back to pristine condition (ie.
      it deletes them all)

    config_dump

      Prints to STDOUT with Data::Dumper the current state of all loaded
      configuration parameters.

    extensions

      By default, we load only *.pm and *.pl files. Use this parameter to
      load different files. Only useful when a directory is passed in as
      opposed to a file.

      Values: Array reference where each element is the name of the
      extension (less the dot). For example, ['pm', 'pl'] is the default.

CAVEATS

    The search parameter is currently only literal text. Regexes have been
    disabled until further extensive testing has been done.

SEE ALSO

    As of 1.19 pre release, the following POD documents haven't been
    created.

    perldoc Devel::Examine::Subs::Preprocessor

      Information related to the 'pre_proc' phase core modules.

    perldoc Devel::Examine::Subs::Prefilter

      Information related to the 'pre_filter' phase core modules.

    perldoc Devel::Examine::Subs::Engine

      Information related to the 'engine' phase core modules.

AUTHOR

    Steve Bertrand, <steveb at cpan.org>

SUPPORT

    You can find documentation for this module with the perldoc command.

        perldoc Devel::Examine::Subs

LICENSE AND COPYRIGHT

    Copyright 2015 Steve Bertrand.

    This program is free software; you can redistribute it and/or modify it
    under the terms of either: the GNU General Public License as published
    by the Free Software Foundation; or the Artistic License.

    See http://dev.perl.org/licenses/ for more information.

